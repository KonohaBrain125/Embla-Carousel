{"version":3,"file":"3180-66dd16b71776010ea289.js","mappings":"uIAAA","sources":["webpack://embla-carousel-docs/./src/components/CodeSandbox/React/SandboxFilesDist/InfiniteScroll/EmblaCarousel.tsx"],"sourcesContent":["export default \"import React, { useCallback, useEffect, useRef, useState } from 'react'\\nimport useEmblaCarousel, { EmblaOptionsType } from 'embla-carousel-react'\\nimport imageByIndex from '../imageByIndex'\\n \\nconst mockApiCall = (\\n  minWait: number,\\n  maxWait: number,\\n  callback: () => void,\\n): void => {\\n  const min = Math.ceil(minWait)\\n  const max = Math.floor(maxWait)\\n  const wait = Math.floor(Math.random() * (max - min + 1)) + min\\n  setTimeout(callback, wait)\\n}\\n \\ntype PropType = {\\n  slides: number[]\\n  options?: EmblaOptionsType\\n}\\n \\nconst EmblaCarousel: React.FC<PropType> = (props) => {\\n  const { options, slides: propSlides } = props\\n  const scrollListener = useRef<() => void>(() => undefined)\\n  const [slides, setSlides] = useState(propSlides)\\n  const [emblaRef, emblaApi] = useEmblaCarousel(options)\\n  const [hasMoreToLoad, setHasMoreToLoad] = useState(true)\\n  const [loadingMore, setLoadingMore] = useState(false)\\n  const [pointerIsDown, setPointerIsDown] = useState(false)\\n \\n  const setPointerDown = useCallback(() => setPointerIsDown(true), [])\\n  const setPointerNotDown = useCallback(() => setPointerIsDown(false), [])\\n \\n  const lastSlideIsInView = useCallback(() => {\\n    if (!emblaApi) return false\\n    const lastSlide = emblaApi.slideNodes().length - 1\\n    return emblaApi.slidesInView().indexOf(lastSlide) !== -1\\n  }, [emblaApi])\\n \\n  const onScroll = useCallback(() => {\\n    if (!emblaApi) return\\n    setLoadingMore((isLoadingMore) => {\\n      if (isLoadingMore) return true\\n      const shouldLoadMore = lastSlideIsInView()\\n      if (shouldLoadMore) emblaApi.off('scroll', scrollListener.current)\\n      return shouldLoadMore\\n    })\\n  }, [emblaApi, setLoadingMore, lastSlideIsInView])\\n \\n  const addScrollListener = useCallback(() => {\\n    if (!emblaApi || !hasMoreToLoad) return\\n    scrollListener.current = () => onScroll()\\n    emblaApi.on('scroll', scrollListener.current)\\n  }, [emblaApi, hasMoreToLoad, onScroll])\\n \\n  const reloadEmbla = useCallback(() => {\\n    if (!emblaApi) return\\n    const oldEngine = emblaApi.internalEngine()\\n    emblaApi.reInit()\\n    const newEngine = emblaApi.internalEngine()\\n    Object.assign(newEngine.scrollBody, oldEngine.scrollBody)\\n    Object.assign(newEngine.location, oldEngine.location)\\n    Object.assign(newEngine.target, oldEngine.target)\\n    const { index } = newEngine.scrollTarget.byDistance(0, false)\\n    newEngine.index.set(index)\\n    newEngine.animation.start()\\n    setLoadingMore(false)\\n  }, [emblaApi])\\n \\n  useEffect(() => {\\n    if (!emblaApi || slides.length === emblaApi.slideNodes().length - 1) return\\n    const engine = emblaApi.internalEngine()\\n    const boundsActive = engine.limit.reachedMax(engine.target.get())\\n    engine.scrollBounds.toggleActive(boundsActive)\\n  }, [emblaApi, slides])\\n \\n  useEffect(() => {\\n    if (!emblaApi || !hasMoreToLoad || pointerIsDown) return\\n    if (slides.length === emblaApi.slideNodes().length - 1) return\\n    reloadEmbla()\\n    addScrollListener()\\n  }, [\\n    emblaApi,\\n    slides,\\n    pointerIsDown,\\n    hasMoreToLoad,\\n    reloadEmbla,\\n    addScrollListener,\\n  ])\\n \\n  useEffect(() => {\\n    if (!emblaApi || hasMoreToLoad) return\\n    if (slides.length === emblaApi.slideNodes().length) return\\n    if (pointerIsDown && !lastSlideIsInView()) return\\n    reloadEmbla()\\n    emblaApi.off('pointerDown', setPointerDown)\\n    emblaApi.off('pointerUp', setPointerNotDown)\\n  }, [\\n    emblaApi,\\n    slides,\\n    hasMoreToLoad,\\n    pointerIsDown,\\n    setPointerDown,\\n    setPointerNotDown,\\n    reloadEmbla,\\n    lastSlideIsInView,\\n  ])\\n \\n  useEffect(() => {\\n    if (!emblaApi) return\\n    emblaApi.on('pointerDown', setPointerDown)\\n    emblaApi.on('pointerUp', setPointerNotDown)\\n    addScrollListener()\\n  }, [emblaApi, setPointerDown, setPointerNotDown, addScrollListener])\\n \\n  useEffect(() => {\\n    if (!loadingMore) return\\n    mockApiCall(1000, 2000, () => {\\n      setSlides((currentSlides) => {\\n        if (currentSlides.length === 20) {\\n          setHasMoreToLoad(false)\\n          return currentSlides\\n        }\\n        const newSlideCount = currentSlides.length + 5\\n        return Array.from(Array(newSlideCount).keys())\\n      })\\n    })\\n  }, [setSlides, loadingMore])\\n \\n  return (\\n    <div className=\\\"embla\\\">\\n      <div className=\\\"embla__viewport\\\" ref={emblaRef}>\\n        <div className=\\\"embla__container\\\">\\n          {slides.map((index) => (\\n            <div className=\\\"embla__slide\\\" key={index}>\\n              <div className=\\\"embla__slide__number\\\">\\n                <span>{index + 1}</span>\\n              </div>\\n              <img\\n                className=\\\"embla__slide__img\\\"\\n                src={imageByIndex(index)}\\n                alt=\\\"Your alt text\\\"\\n              />\\n            </div>\\n          ))}\\n          {hasMoreToLoad && (\\n            <div\\n              className={'embla-infinite-scroll'.concat(\\n                loadingMore ? ' embla-infinite-scroll--loading-more' : '',\\n              )}\\n            >\\n              <span className=\\\"embla-infinite-scroll__spinner\\\" />\\n            </div>\\n          )}\\n        </div>\\n      </div>\\n    </div>\\n  )\\n}\\n \\nexport default EmblaCarousel\\n\";"],"names":[],"sourceRoot":""}