{"version":3,"file":"906-6a11b818568c2357bef8.js","mappings":"qIAAA,s7K","sources":["webpack://embla-carousel-docs/./src/components/CodeSandbox/React/SandboxFilesDist/InfiniteScroll/EmblaCarousel.jsx"],"sourcesContent":["export default \"import React, { useCallback, useEffect, useRef, useState } from 'react';\\nimport useEmblaCarousel from 'embla-carousel-react';\\nimport imageByIndex from '../imageByIndex';\\n\\nconst mockApiCall = (minWait, maxWait, callback) => {\\n    const min = Math.ceil(minWait);\\n    const max = Math.floor(maxWait);\\n    const wait = Math.floor(Math.random() * (max - min + 1)) + min;\\n    setTimeout(callback, wait);\\n};\\n\\nconst EmblaCarousel = (props) => {\\n    const { options, slides: propSlides } = props;\\n    const scrollListener = useRef(() => undefined);\\n    const [slides, setSlides] = useState(propSlides);\\n    const [emblaRef, emblaApi] = useEmblaCarousel(options);\\n    const [hasMoreToLoad, setHasMoreToLoad] = useState(true);\\n    const [loadingMore, setLoadingMore] = useState(false);\\n    const [pointerIsDown, setPointerIsDown] = useState(false);\\n    \\n    const setPointerDown = useCallback(() => setPointerIsDown(true), []);\\n    const setPointerNotDown = useCallback(() => setPointerIsDown(false), []);\\n    \\n    const lastSlideIsInView = useCallback(() => {\\n        if (!emblaApi)\\n            return false;\\n        const lastSlide = emblaApi.slideNodes().length - 1;\\n        return emblaApi.slidesInView().indexOf(lastSlide) !== -1;\\n    }, [emblaApi]);\\n    \\n    const onScroll = useCallback(() => {\\n        if (!emblaApi)\\n            return;\\n        setLoadingMore((isLoadingMore) => {\\n            if (isLoadingMore)\\n                return true;\\n            const shouldLoadMore = lastSlideIsInView();\\n            if (shouldLoadMore)\\n                emblaApi.off('scroll', scrollListener.current);\\n            return shouldLoadMore;\\n        });\\n    }, [emblaApi, setLoadingMore, lastSlideIsInView]);\\n    \\n    const addScrollListener = useCallback(() => {\\n        if (!emblaApi || !hasMoreToLoad)\\n            return;\\n        scrollListener.current = () => onScroll();\\n        emblaApi.on('scroll', scrollListener.current);\\n    }, [emblaApi, hasMoreToLoad, onScroll]);\\n    \\n    const reloadEmbla = useCallback(() => {\\n        if (!emblaApi)\\n            return;\\n        const oldEngine = emblaApi.internalEngine();\\n        emblaApi.reInit();\\n        const newEngine = emblaApi.internalEngine();\\n        Object.assign(newEngine.scrollBody, oldEngine.scrollBody);\\n        Object.assign(newEngine.location, oldEngine.location);\\n        Object.assign(newEngine.target, oldEngine.target);\\n        const { index } = newEngine.scrollTarget.byDistance(0, false);\\n        newEngine.index.set(index);\\n        newEngine.animation.start();\\n        setLoadingMore(false);\\n    }, [emblaApi]);\\n    \\n    useEffect(() => {\\n        if (!emblaApi || slides.length === emblaApi.slideNodes().length - 1)\\n            return;\\n        const engine = emblaApi.internalEngine();\\n        const boundsActive = engine.limit.reachedMax(engine.target.get());\\n        engine.scrollBounds.toggleActive(boundsActive);\\n    }, [emblaApi, slides]);\\n    \\n    useEffect(() => {\\n        if (!emblaApi || !hasMoreToLoad || pointerIsDown)\\n            return;\\n        if (slides.length === emblaApi.slideNodes().length - 1)\\n            return;\\n        reloadEmbla();\\n        addScrollListener();\\n    }, [\\n        emblaApi,\\n        slides,\\n        pointerIsDown,\\n        hasMoreToLoad,\\n        reloadEmbla,\\n        addScrollListener,\\n    ]);\\n    \\n    useEffect(() => {\\n        if (!emblaApi || hasMoreToLoad)\\n            return;\\n        if (slides.length === emblaApi.slideNodes().length)\\n            return;\\n        if (pointerIsDown && !lastSlideIsInView())\\n            return;\\n        reloadEmbla();\\n        emblaApi.off('pointerDown', setPointerDown);\\n        emblaApi.off('pointerUp', setPointerNotDown);\\n    }, [\\n        emblaApi,\\n        slides,\\n        hasMoreToLoad,\\n        pointerIsDown,\\n        setPointerDown,\\n        setPointerNotDown,\\n        reloadEmbla,\\n        lastSlideIsInView,\\n    ]);\\n    \\n    useEffect(() => {\\n        if (!emblaApi)\\n            return;\\n        emblaApi.on('pointerDown', setPointerDown);\\n        emblaApi.on('pointerUp', setPointerNotDown);\\n        addScrollListener();\\n    }, [emblaApi, setPointerDown, setPointerNotDown, addScrollListener]);\\n    \\n    useEffect(() => {\\n        if (!loadingMore)\\n            return;\\n        mockApiCall(1000, 2000, () => {\\n            setSlides((currentSlides) => {\\n                if (currentSlides.length === 20) {\\n                    setHasMoreToLoad(false);\\n                    return currentSlides;\\n                }\\n                const newSlideCount = currentSlides.length + 5;\\n                return Array.from(Array(newSlideCount).keys());\\n            });\\n        });\\n    }, [setSlides, loadingMore]);\\n    \\n    return (<div className=\\\"embla\\\">\\n      <div className=\\\"embla__viewport\\\" ref={emblaRef}>\\n        <div className=\\\"embla__container\\\">\\n          {slides.map((index) => (<div className=\\\"embla__slide\\\" key={index}>\\n              <div className=\\\"embla__slide__number\\\">\\n                <span>{index + 1}</span>\\n              </div>\\n              <img className=\\\"embla__slide__img\\\" src={imageByIndex(index)} alt=\\\"Your alt text\\\"/>\\n            </div>))}\\n          {hasMoreToLoad && (<div className={'embla-infinite-scroll'.concat(loadingMore ? ' embla-infinite-scroll--loading-more' : '')}>\\n              <span className=\\\"embla-infinite-scroll__spinner\\\"/>\\n            </div>)}\\n        </div>\\n      </div>\\n    </div>);\\n};\\n\\nexport default EmblaCarousel;\\n\";"],"names":[],"sourceRoot":""}